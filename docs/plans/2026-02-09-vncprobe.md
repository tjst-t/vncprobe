# vncprobe Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Build a Go CLI tool that connects to VNC servers to capture screenshots, send keyboard input, and perform mouse operations, testable entirely offline via a fake VNC server.

**Architecture:** CLI binary with subcommands (capture/key/type/click/move) that delegates to a VNC client wrapper built on `github.com/kward/go-vnc`. All VNC operations go through a `VNCClient` interface so unit tests use mocks, while E2E tests use a custom fake RFB server.

**Tech Stack:** Go 1.22+, `github.com/kward/go-vnc` (active fork of mitchellh/go-vnc with keys/buttons packages), standard library `image/png`, `flag` for CLI parsing.

---

## Task 1: Project Scaffolding

**Files:**
- Create: `go.mod`
- Create: `main.go` (minimal placeholder)
- Create: `testdata/generate_test.go` (generates test image)
- Create: `testdata/expected.png`

**Step 1: Initialize Go module**

Run:
```bash
cd /home/ubuntu/ghq/github.com/tjst-t/vncprobe
go mod init github.com/tjst-t/vncprobe
```

**Step 2: Create minimal main.go**

```go
package main

import (
	"fmt"
	"os"
)

func main() {
	if len(os.Args) < 2 {
		fmt.Fprintln(os.Stderr, "Usage: vncprobe <command> [options]")
		fmt.Fprintln(os.Stderr, "Commands: capture, key, type, click, move")
		os.Exit(1)
	}
	fmt.Fprintln(os.Stderr, "not implemented")
	os.Exit(1)
}
```

**Step 3: Create test image generator and generate testdata/expected.png**

Create `testdata/generate_test.go`:
```go
package testdata_test

import (
	"image"
	"image/color"
	"image/png"
	"os"
	"testing"
)

func TestGenerateExpectedPNG(t *testing.T) {
	const path = "expected.png"
	if _, err := os.Stat(path); err == nil {
		t.Skip("expected.png already exists")
	}

	img := image.NewRGBA(image.Rect(0, 0, 64, 64))
	for y := 0; y < 64; y++ {
		for x := 0; x < 64; x++ {
			img.Set(x, y, color.RGBA{R: uint8(x * 4), G: uint8(y * 4), B: 128, A: 255})
		}
	}

	f, err := os.Create(path)
	if err != nil {
		t.Fatal(err)
	}
	defer f.Close()
	if err := png.Encode(f, img); err != nil {
		t.Fatal(err)
	}
}
```

Run:
```bash
cd /home/ubuntu/ghq/github.com/tjst-t/vncprobe
go test ./testdata/ -run TestGenerateExpectedPNG -v
```
Expected: PASS, `testdata/expected.png` created (64x64 gradient image).

**Step 4: Verify build**

Run:
```bash
go build -o vncprobe .
```
Expected: Binary `vncprobe` created successfully.

**Step 5: Commit**

```bash
git add go.mod main.go testdata/
git commit -m "feat: project scaffolding with test image"
```

---

## Task 2: Keymap — Tests First

**Files:**
- Create: `vnc/keymap.go`
- Create: `vnc/keymap_test.go`

**Step 1: Write the failing keymap tests**

Create `vnc/keymap_test.go`:
```go
package vnc

import (
	"testing"
)

func TestParseKeySequence_SingleKeys(t *testing.T) {
	tests := []struct {
		input string
		want  []KeyAction
	}{
		{"enter", []KeyAction{{Key: 0xff0d, Down: true}, {Key: 0xff0d, Down: false}}},
		{"tab", []KeyAction{{Key: 0xff09, Down: true}, {Key: 0xff09, Down: false}}},
		{"escape", []KeyAction{{Key: 0xff1b, Down: true}, {Key: 0xff1b, Down: false}}},
		{"backspace", []KeyAction{{Key: 0xff08, Down: true}, {Key: 0xff08, Down: false}}},
		{"delete", []KeyAction{{Key: 0xffff, Down: true}, {Key: 0xffff, Down: false}}},
		{"space", []KeyAction{{Key: 0x0020, Down: true}, {Key: 0x0020, Down: false}}},
		{"up", []KeyAction{{Key: 0xff52, Down: true}, {Key: 0xff52, Down: false}}},
		{"down", []KeyAction{{Key: 0xff54, Down: true}, {Key: 0xff54, Down: false}}},
		{"left", []KeyAction{{Key: 0xff51, Down: true}, {Key: 0xff51, Down: false}}},
		{"right", []KeyAction{{Key: 0xff53, Down: true}, {Key: 0xff53, Down: false}}},
		{"home", []KeyAction{{Key: 0xff50, Down: true}, {Key: 0xff50, Down: false}}},
		{"end", []KeyAction{{Key: 0xff57, Down: true}, {Key: 0xff57, Down: false}}},
		{"pageup", []KeyAction{{Key: 0xff55, Down: true}, {Key: 0xff55, Down: false}}},
		{"pagedown", []KeyAction{{Key: 0xff56, Down: true}, {Key: 0xff56, Down: false}}},
		{"f1", []KeyAction{{Key: 0xffbe, Down: true}, {Key: 0xffbe, Down: false}}},
		{"f12", []KeyAction{{Key: 0xffc9, Down: true}, {Key: 0xffc9, Down: false}}},
	}

	for _, tt := range tests {
		t.Run(tt.input, func(t *testing.T) {
			got, err := ParseKeySequence(tt.input)
			if err != nil {
				t.Fatalf("ParseKeySequence(%q) error: %v", tt.input, err)
			}
			if len(got) != len(tt.want) {
				t.Fatalf("ParseKeySequence(%q) got %d actions, want %d", tt.input, len(got), len(tt.want))
			}
			for i, g := range got {
				if g != tt.want[i] {
					t.Errorf("ParseKeySequence(%q)[%d] = %+v, want %+v", tt.input, i, g, tt.want[i])
				}
			}
		})
	}
}

func TestParseKeySequence_ModifierCombos(t *testing.T) {
	tests := []struct {
		input string
		want  []KeyAction
	}{
		{"ctrl-c", []KeyAction{
			{Key: 0xffe3, Down: true},  // ControlLeft press
			{Key: 0x0063, Down: true},  // 'c' press
			{Key: 0x0063, Down: false}, // 'c' release
			{Key: 0xffe3, Down: false}, // ControlLeft release
		}},
		{"alt-f4", []KeyAction{
			{Key: 0xffe9, Down: true},  // AltLeft press
			{Key: 0xffc1, Down: true},  // F4 press
			{Key: 0xffc1, Down: false}, // F4 release
			{Key: 0xffe9, Down: false}, // AltLeft release
		}},
		{"shift-a", []KeyAction{
			{Key: 0xffe1, Down: true},  // ShiftLeft press
			{Key: 0x0061, Down: true},  // 'a' press
			{Key: 0x0061, Down: false}, // 'a' release
			{Key: 0xffe1, Down: false}, // ShiftLeft release
		}},
		{"ctrl-alt-delete", []KeyAction{
			{Key: 0xffe3, Down: true},  // ControlLeft press
			{Key: 0xffe9, Down: true},  // AltLeft press
			{Key: 0xffff, Down: true},  // Delete press
			{Key: 0xffff, Down: false}, // Delete release
			{Key: 0xffe9, Down: false}, // AltLeft release
			{Key: 0xffe3, Down: false}, // ControlLeft release
		}},
	}

	for _, tt := range tests {
		t.Run(tt.input, func(t *testing.T) {
			got, err := ParseKeySequence(tt.input)
			if err != nil {
				t.Fatalf("ParseKeySequence(%q) error: %v", tt.input, err)
			}
			if len(got) != len(tt.want) {
				t.Fatalf("ParseKeySequence(%q) got %d actions, want %d\ngot:  %+v\nwant: %+v", tt.input, len(got), len(tt.want), got, tt.want)
			}
			for i, g := range got {
				if g != tt.want[i] {
					t.Errorf("ParseKeySequence(%q)[%d] = %+v, want %+v", tt.input, i, g, tt.want[i])
				}
			}
		})
	}
}

func TestParseKeySequence_SingleChar(t *testing.T) {
	got, err := ParseKeySequence("a")
	if err != nil {
		t.Fatalf("ParseKeySequence(%q) error: %v", "a", err)
	}
	want := []KeyAction{
		{Key: 0x0061, Down: true},
		{Key: 0x0061, Down: false},
	}
	if len(got) != len(want) {
		t.Fatalf("got %d actions, want %d", len(got), len(want))
	}
	for i, g := range got {
		if g != want[i] {
			t.Errorf("[%d] = %+v, want %+v", i, g, want[i])
		}
	}
}

func TestParseKeySequence_UnknownKey(t *testing.T) {
	_, err := ParseKeySequence("nonexistentkey")
	if err == nil {
		t.Fatal("ParseKeySequence(\"nonexistentkey\") expected error, got nil")
	}
}

func TestRuneToKeyCode(t *testing.T) {
	tests := []struct {
		r    rune
		want uint32
	}{
		{'a', 0x0061},
		{'A', 0x0041},
		{'0', 0x0030},
		{' ', 0x0020},
		{'!', 0x0021},
	}
	for _, tt := range tests {
		t.Run(string(tt.r), func(t *testing.T) {
			got, err := RuneToKeyCode(tt.r)
			if err != nil {
				t.Fatalf("RuneToKeyCode(%q) error: %v", tt.r, err)
			}
			if got != tt.want {
				t.Errorf("RuneToKeyCode(%q) = 0x%04x, want 0x%04x", tt.r, got, tt.want)
			}
		})
	}
}
```

**Step 2: Run test to verify it fails**

Run:
```bash
go test ./vnc/ -run TestParseKeySequence -v
```
Expected: FAIL — package/types don't exist yet.

**Step 3: Write minimal keymap implementation**

Create `vnc/keymap.go`:
```go
package vnc

import (
	"fmt"
	"strings"
)

// KeyAction represents a single key press or release event.
type KeyAction struct {
	Key  uint32
	Down bool
}

// Named key to VNC keysym mapping.
var namedKeys = map[string]uint32{
	"enter":     0xff0d,
	"return":    0xff0d,
	"tab":       0xff09,
	"escape":    0xff1b,
	"esc":       0xff1b,
	"backspace": 0xff08,
	"delete":    0xffff,
	"space":     0x0020,
	"up":        0xff52,
	"down":      0xff54,
	"left":      0xff51,
	"right":     0xff53,
	"home":      0xff50,
	"end":       0xff57,
	"pageup":    0xff55,
	"pagedown":  0xff56,
	"insert":    0xff63,
	"f1":        0xffbe,
	"f2":        0xffbf,
	"f3":        0xffc0,
	"f4":        0xffc1,
	"f5":        0xffc2,
	"f6":        0xffc3,
	"f7":        0xffc4,
	"f8":        0xffc5,
	"f9":        0xffc6,
	"f10":       0xffc7,
	"f11":       0xffc8,
	"f12":       0xffc9,
}

// Modifier key names to VNC keysym mapping.
var modifierKeys = map[string]uint32{
	"ctrl":  0xffe3, // ControlLeft
	"alt":   0xffe9, // AltLeft
	"shift": 0xffe1, // ShiftLeft
	"super": 0xffeb, // SuperLeft
	"meta":  0xffe7, // MetaLeft
}

// RuneToKeyCode converts a rune to a VNC keysym code.
func RuneToKeyCode(r rune) (uint32, error) {
	if r >= 0x20 && r <= 0x7e {
		return uint32(r), nil
	}
	return 0, fmt.Errorf("unsupported rune: %q (0x%04x)", r, r)
}

// ParseKeySequence parses a key string like "enter", "ctrl-c", "alt-f4"
// and returns the sequence of key actions (press/release).
func ParseKeySequence(input string) ([]KeyAction, error) {
	input = strings.ToLower(input)
	parts := strings.Split(input, "-")

	// Check if this is a modifier combo (has known modifier prefix)
	var modifiers []uint32
	finalKeyStr := ""

	for i, part := range parts {
		if code, ok := modifierKeys[part]; ok {
			modifiers = append(modifiers, code)
		} else {
			// Rejoin remaining parts as the final key (handles e.g. "ctrl-alt-delete")
			finalKeyStr = strings.Join(parts[i:], "-")
			break
		}
	}

	if finalKeyStr == "" {
		// All parts were modifiers — treat the last modifier as the key
		if len(modifiers) == 0 {
			return nil, fmt.Errorf("empty key sequence")
		}
		// e.g. just "ctrl" — press and release ctrl
		lastMod := modifiers[len(modifiers)-1]
		modifiers = modifiers[:len(modifiers)-1]
		finalKeyStr = ""
		// Build actions
		var actions []KeyAction
		for _, m := range modifiers {
			actions = append(actions, KeyAction{Key: m, Down: true})
		}
		actions = append(actions, KeyAction{Key: lastMod, Down: true})
		actions = append(actions, KeyAction{Key: lastMod, Down: false})
		for i := len(modifiers) - 1; i >= 0; i-- {
			actions = append(actions, KeyAction{Key: modifiers[i], Down: false})
		}
		return actions, nil
	}

	// Resolve the final key
	var finalKeyCode uint32
	if code, ok := namedKeys[finalKeyStr]; ok {
		finalKeyCode = code
	} else if len(finalKeyStr) == 1 {
		r := rune(finalKeyStr[0])
		code, err := RuneToKeyCode(r)
		if err != nil {
			return nil, err
		}
		finalKeyCode = code
	} else {
		return nil, fmt.Errorf("unknown key: %q", finalKeyStr)
	}

	// Build the action sequence: modifiers down, key down, key up, modifiers up (reverse)
	var actions []KeyAction
	for _, m := range modifiers {
		actions = append(actions, KeyAction{Key: m, Down: true})
	}
	actions = append(actions, KeyAction{Key: finalKeyCode, Down: true})
	actions = append(actions, KeyAction{Key: finalKeyCode, Down: false})
	for i := len(modifiers) - 1; i >= 0; i-- {
		actions = append(actions, KeyAction{Key: modifiers[i], Down: false})
	}
	return actions, nil
}
```

**Step 4: Run tests to verify they pass**

Run:
```bash
go test ./vnc/ -v
```
Expected: All keymap tests PASS.

**Step 5: Commit**

```bash
git add vnc/
git commit -m "feat: keymap with ParseKeySequence and RuneToKeyCode"
```

---

## Task 3: VNC Client Interface and Mock

**Files:**
- Create: `vnc/client.go`
- Create: `vnc/client_test.go`

**Step 1: Write the VNC client interface and mock tests**

Create `vnc/client.go`:
```go
package vnc

import (
	"image"
	"time"
)

// VNCClient is the interface for VNC operations.
type VNCClient interface {
	Connect(addr string, password string, timeout time.Duration) error
	Capture() (image.Image, error)
	SendKey(keycode uint32, down bool) error
	SendPointer(x, y uint16, buttonMask uint8) error
	Close() error
}
```

Create `vnc/client_test.go`:
```go
package vnc

import (
	"image"
	"testing"
	"time"
)

// mockClient is a test double that records all calls.
type mockClient struct {
	connected    bool
	closed       bool
	captureImage image.Image
	captureErr   error
	keyEvents    []KeyAction
	ptrEvents    []pointerEvent
}

type pointerEvent struct {
	x, y       uint16
	buttonMask uint8
}

func (m *mockClient) Connect(addr string, password string, timeout time.Duration) error {
	m.connected = true
	return nil
}

func (m *mockClient) Capture() (image.Image, error) {
	return m.captureImage, m.captureErr
}

func (m *mockClient) SendKey(keycode uint32, down bool) error {
	m.keyEvents = append(m.keyEvents, KeyAction{Key: keycode, Down: down})
	return nil
}

func (m *mockClient) SendPointer(x, y uint16, buttonMask uint8) error {
	m.ptrEvents = append(m.ptrEvents, pointerEvent{x: x, y: y, buttonMask: buttonMask})
	return nil
}

func (m *mockClient) Close() error {
	m.closed = true
	return nil
}

func TestMockImplementsInterface(t *testing.T) {
	var _ VNCClient = &mockClient{}
}
```

**Step 2: Run test to verify it passes**

Run:
```bash
go test ./vnc/ -run TestMockImplementsInterface -v
```
Expected: PASS.

**Step 3: Commit**

```bash
git add vnc/client.go vnc/client_test.go
git commit -m "feat: VNCClient interface and mock"
```

---

## Task 4: Input Logic — Tests First

**Files:**
- Create: `vnc/input.go`
- Create: `vnc/input_test.go`

**Step 1: Write failing input tests**

Create `vnc/input_test.go`:
```go
package vnc

import (
	"testing"
)

func TestSendKeySequence(t *testing.T) {
	mock := &mockClient{}
	actions := []KeyAction{
		{Key: 0xff0d, Down: true},
		{Key: 0xff0d, Down: false},
	}
	err := SendKeySequence(mock, actions)
	if err != nil {
		t.Fatalf("SendKeySequence error: %v", err)
	}
	if len(mock.keyEvents) != 2 {
		t.Fatalf("got %d key events, want 2", len(mock.keyEvents))
	}
	if mock.keyEvents[0].Key != 0xff0d || mock.keyEvents[0].Down != true {
		t.Errorf("event[0] = %+v, want {Key:0xff0d, Down:true}", mock.keyEvents[0])
	}
	if mock.keyEvents[1].Key != 0xff0d || mock.keyEvents[1].Down != false {
		t.Errorf("event[1] = %+v, want {Key:0xff0d, Down:false}", mock.keyEvents[1])
	}
}

func TestSendTypeString(t *testing.T) {
	mock := &mockClient{}
	err := SendTypeString(mock, "Hi")
	if err != nil {
		t.Fatalf("SendTypeString error: %v", err)
	}
	// 'H' press, 'H' release, 'i' press, 'i' release
	if len(mock.keyEvents) != 4 {
		t.Fatalf("got %d key events, want 4", len(mock.keyEvents))
	}
	wantKeys := []struct {
		key  uint32
		down bool
	}{
		{0x0048, true},  // 'H' press
		{0x0048, false}, // 'H' release
		{0x0069, true},  // 'i' press
		{0x0069, false}, // 'i' release
	}
	for i, wk := range wantKeys {
		if mock.keyEvents[i].Key != wk.key || mock.keyEvents[i].Down != wk.down {
			t.Errorf("event[%d] = {Key:0x%04x, Down:%v}, want {Key:0x%04x, Down:%v}",
				i, mock.keyEvents[i].Key, mock.keyEvents[i].Down, wk.key, wk.down)
		}
	}
}

func TestSendClick(t *testing.T) {
	mock := &mockClient{}
	err := SendClick(mock, 400, 300, 1)
	if err != nil {
		t.Fatalf("SendClick error: %v", err)
	}
	if len(mock.ptrEvents) != 2 {
		t.Fatalf("got %d pointer events, want 2", len(mock.ptrEvents))
	}
	// press
	if mock.ptrEvents[0].x != 400 || mock.ptrEvents[0].y != 300 || mock.ptrEvents[0].buttonMask != 1 {
		t.Errorf("press event = %+v, want {x:400, y:300, buttonMask:1}", mock.ptrEvents[0])
	}
	// release
	if mock.ptrEvents[1].x != 400 || mock.ptrEvents[1].y != 300 || mock.ptrEvents[1].buttonMask != 0 {
		t.Errorf("release event = %+v, want {x:400, y:300, buttonMask:0}", mock.ptrEvents[1])
	}
}

func TestSendClick_RightButton(t *testing.T) {
	mock := &mockClient{}
	err := SendClick(mock, 100, 200, 4) // right button = bitmask 4
	if err != nil {
		t.Fatalf("SendClick error: %v", err)
	}
	if len(mock.ptrEvents) != 2 {
		t.Fatalf("got %d pointer events, want 2", len(mock.ptrEvents))
	}
	if mock.ptrEvents[0].buttonMask != 4 {
		t.Errorf("press buttonMask = %d, want 4", mock.ptrEvents[0].buttonMask)
	}
	if mock.ptrEvents[1].buttonMask != 0 {
		t.Errorf("release buttonMask = %d, want 0", mock.ptrEvents[1].buttonMask)
	}
}

func TestSendMove(t *testing.T) {
	mock := &mockClient{}
	err := SendMove(mock, 500, 600)
	if err != nil {
		t.Fatalf("SendMove error: %v", err)
	}
	if len(mock.ptrEvents) != 1 {
		t.Fatalf("got %d pointer events, want 1", len(mock.ptrEvents))
	}
	if mock.ptrEvents[0].x != 500 || mock.ptrEvents[0].y != 600 || mock.ptrEvents[0].buttonMask != 0 {
		t.Errorf("move event = %+v, want {x:500, y:600, buttonMask:0}", mock.ptrEvents[0])
	}
}
```

**Step 2: Run test to verify it fails**

Run:
```bash
go test ./vnc/ -run "TestSend" -v
```
Expected: FAIL — functions not defined.

**Step 3: Write input.go implementation**

Create `vnc/input.go`:
```go
package vnc

import "fmt"

// SendKeySequence sends a sequence of key press/release actions.
func SendKeySequence(client VNCClient, actions []KeyAction) error {
	for _, a := range actions {
		if err := client.SendKey(a.Key, a.Down); err != nil {
			return fmt.Errorf("send key 0x%04x (down=%v): %w", a.Key, a.Down, err)
		}
	}
	return nil
}

// SendTypeString types a string by sending key press/release for each rune.
func SendTypeString(client VNCClient, text string) error {
	for _, r := range text {
		code, err := RuneToKeyCode(r)
		if err != nil {
			return fmt.Errorf("type string: %w", err)
		}
		if err := client.SendKey(code, true); err != nil {
			return fmt.Errorf("type string press %q: %w", r, err)
		}
		if err := client.SendKey(code, false); err != nil {
			return fmt.Errorf("type string release %q: %w", r, err)
		}
	}
	return nil
}

// SendClick sends a mouse button press and release at the given position.
func SendClick(client VNCClient, x, y uint16, buttonMask uint8) error {
	if err := client.SendPointer(x, y, buttonMask); err != nil {
		return fmt.Errorf("click press at (%d,%d): %w", x, y, err)
	}
	if err := client.SendPointer(x, y, 0); err != nil {
		return fmt.Errorf("click release at (%d,%d): %w", x, y, err)
	}
	return nil
}

// SendMove sends a pointer movement without any button press.
func SendMove(client VNCClient, x, y uint16) error {
	if err := client.SendPointer(x, y, 0); err != nil {
		return fmt.Errorf("move to (%d,%d): %w", x, y, err)
	}
	return nil
}
```

**Step 4: Run tests to verify they pass**

Run:
```bash
go test ./vnc/ -v
```
Expected: All tests PASS.

**Step 5: Commit**

```bash
git add vnc/input.go vnc/input_test.go
git commit -m "feat: input helpers (SendKeySequence, SendTypeString, SendClick, SendMove)"
```

---

## Task 5: Capture Logic — Tests First

**Files:**
- Create: `vnc/capture.go`
- Create: `vnc/capture_test.go`

**Step 1: Write failing capture tests**

Create `vnc/capture_test.go`:
```go
package vnc

import (
	"bytes"
	"image"
	"image/color"
	"image/png"
	"testing"
)

func TestSaveImagePNG(t *testing.T) {
	img := image.NewRGBA(image.Rect(0, 0, 4, 4))
	for y := 0; y < 4; y++ {
		for x := 0; x < 4; x++ {
			img.Set(x, y, color.RGBA{R: 255, G: 0, B: 0, A: 255})
		}
	}

	var buf bytes.Buffer
	err := SaveImagePNG(&buf, img)
	if err != nil {
		t.Fatalf("SaveImagePNG error: %v", err)
	}

	// Decode and verify
	decoded, err := png.Decode(&buf)
	if err != nil {
		t.Fatalf("png.Decode error: %v", err)
	}
	bounds := decoded.Bounds()
	if bounds.Dx() != 4 || bounds.Dy() != 4 {
		t.Fatalf("decoded size = %dx%d, want 4x4", bounds.Dx(), bounds.Dy())
	}
	r, g, b, a := decoded.At(0, 0).RGBA()
	if r>>8 != 255 || g>>8 != 0 || b>>8 != 0 || a>>8 != 255 {
		t.Errorf("pixel (0,0) = (%d,%d,%d,%d), want (255,0,0,255)", r>>8, g>>8, b>>8, a>>8)
	}
}

func TestCaptureToFile(t *testing.T) {
	img := image.NewRGBA(image.Rect(0, 0, 2, 2))
	img.Set(0, 0, color.RGBA{R: 100, G: 200, B: 50, A: 255})

	mock := &mockClient{captureImage: img}

	outPath := t.TempDir() + "/out.png"
	err := CaptureToFile(mock, outPath)
	if err != nil {
		t.Fatalf("CaptureToFile error: %v", err)
	}

	// Read back and verify
	decoded, err := loadPNG(outPath)
	if err != nil {
		t.Fatalf("loadPNG error: %v", err)
	}
	bounds := decoded.Bounds()
	if bounds.Dx() != 2 || bounds.Dy() != 2 {
		t.Fatalf("decoded size = %dx%d, want 2x2", bounds.Dx(), bounds.Dy())
	}
}
```

**Step 2: Run test to verify it fails**

Run:
```bash
go test ./vnc/ -run "TestSaveImagePNG|TestCaptureToFile" -v
```
Expected: FAIL — functions not defined.

**Step 3: Write capture.go implementation**

Create `vnc/capture.go`:
```go
package vnc

import (
	"fmt"
	"image"
	"image/png"
	"io"
	"os"
)

// SaveImagePNG encodes an image as PNG and writes it to w.
func SaveImagePNG(w io.Writer, img image.Image) error {
	return png.Encode(w, img)
}

// CaptureToFile captures the screen from the VNC client and saves it as PNG.
func CaptureToFile(client VNCClient, path string) error {
	img, err := client.Capture()
	if err != nil {
		return fmt.Errorf("capture: %w", err)
	}

	f, err := os.Create(path)
	if err != nil {
		return fmt.Errorf("create %s: %w", path, err)
	}
	defer f.Close()

	if err := SaveImagePNG(f, img); err != nil {
		return fmt.Errorf("save PNG %s: %w", path, err)
	}
	return nil
}

// loadPNG loads a PNG image from a file. Used by tests.
func loadPNG(path string) (image.Image, error) {
	f, err := os.Open(path)
	if err != nil {
		return nil, err
	}
	defer f.Close()
	return png.Decode(f)
}
```

**Step 4: Run tests to verify they pass**

Run:
```bash
go test ./vnc/ -v
```
Expected: All tests PASS.

**Step 5: Commit**

```bash
git add vnc/capture.go vnc/capture_test.go
git commit -m "feat: capture logic (SaveImagePNG, CaptureToFile)"
```

---

## Task 6: Fake VNC Server — Tests First

**Files:**
- Create: `testutil/fakeserver.go`
- Create: `testutil/fakeserver_test.go`

This is the core of the test infrastructure. The fake server implements the minimum RFB 003.008 protocol to support: handshake, ServerInit, FramebufferUpdate with Raw encoding, and recording KeyEvent/PointerEvent from the client.

**Step 1: Write failing fake server tests**

Create `testutil/fakeserver_test.go`:
```go
package testutil

import (
	"encoding/binary"
	"fmt"
	"image"
	"image/color"
	"net"
	"testing"
)

func testImage() image.Image {
	img := image.NewRGBA(image.Rect(0, 0, 4, 4))
	for y := 0; y < 4; y++ {
		for x := 0; x < 4; x++ {
			img.Set(x, y, color.RGBA{R: uint8(x * 60), G: uint8(y * 60), B: 128, A: 255})
		}
	}
	return img
}

func TestFakeServerHandshake(t *testing.T) {
	srv := StartFakeVNCServer(t, testImage())

	conn, err := net.Dial("tcp", srv.Addr)
	if err != nil {
		t.Fatalf("dial error: %v", err)
	}
	defer conn.Close()

	// Read server protocol version
	buf := make([]byte, 12)
	if _, err := conn.Read(buf); err != nil {
		t.Fatalf("read version error: %v", err)
	}
	if string(buf) != "RFB 003.008\n" {
		t.Fatalf("version = %q, want %q", string(buf), "RFB 003.008\n")
	}

	// Send client protocol version
	if _, err := conn.Write([]byte("RFB 003.008\n")); err != nil {
		t.Fatalf("write version error: %v", err)
	}

	// Read security types (1 type: None=1)
	secBuf := make([]byte, 2)
	if _, err := conn.Read(secBuf); err != nil {
		t.Fatalf("read security types error: %v", err)
	}
	if secBuf[0] != 1 || secBuf[1] != 1 {
		t.Fatalf("security types = %v, want [1, 1]", secBuf)
	}

	// Send selected security type (None=1)
	if _, err := conn.Write([]byte{1}); err != nil {
		t.Fatalf("write security type error: %v", err)
	}

	// Read SecurityResult (0 = OK)
	var secResult uint32
	if err := binary.Read(conn, binary.BigEndian, &secResult); err != nil {
		t.Fatalf("read security result error: %v", err)
	}
	if secResult != 0 {
		t.Fatalf("security result = %d, want 0", secResult)
	}

	// Send ClientInit (shared=1)
	if _, err := conn.Write([]byte{1}); err != nil {
		t.Fatalf("write client init error: %v", err)
	}

	// Read ServerInit
	var width, height uint16
	if err := binary.Read(conn, binary.BigEndian, &width); err != nil {
		t.Fatalf("read width error: %v", err)
	}
	if err := binary.Read(conn, binary.BigEndian, &height); err != nil {
		t.Fatalf("read height error: %v", err)
	}
	if width != 4 || height != 4 {
		t.Fatalf("size = %dx%d, want 4x4", width, height)
	}
}

func TestFakeServerRecordsKeyEvent(t *testing.T) {
	srv := StartFakeVNCServer(t, testImage())
	conn := doHandshake(t, srv.Addr)
	defer conn.Close()

	// Send KeyEvent: msg-type=4, down-flag=1, padding=0,0, key=0xff0d
	keyMsg := []byte{4, 1, 0, 0, 0, 0, 0xff, 0x0d}
	if _, err := conn.Write(keyMsg); err != nil {
		t.Fatalf("write key event error: %v", err)
	}

	// Give server time to process
	// Send another key event to ensure first one is processed
	keyMsg2 := []byte{4, 0, 0, 0, 0, 0, 0xff, 0x0d}
	if _, err := conn.Write(keyMsg2); err != nil {
		t.Fatalf("write key event 2 error: %v", err)
	}

	// Read events from server
	events := srv.GetKeyEvents()
	// May need a small retry since server reads async
	for i := 0; i < 50 && len(events) < 2; i++ {
		events = srv.GetKeyEvents()
		if len(events) < 2 {
			// small sleep
			import_sleep(t)
		}
	}
	if len(events) < 2 {
		t.Fatalf("got %d key events, want 2", len(events))
	}
	if events[0].Key != 0xff0d || events[0].DownFlag != true {
		t.Errorf("event[0] = %+v, want {Key:0xff0d, DownFlag:true}", events[0])
	}
	if events[1].Key != 0xff0d || events[1].DownFlag != false {
		t.Errorf("event[1] = %+v, want {Key:0xff0d, DownFlag:false}", events[1])
	}
}

func TestFakeServerRecordsPointerEvent(t *testing.T) {
	srv := StartFakeVNCServer(t, testImage())
	conn := doHandshake(t, srv.Addr)
	defer conn.Close()

	// Send PointerEvent: msg-type=5, button-mask=1, x=0x0190(400), y=0x012c(300)
	ptrMsg := []byte{5, 1, 0x01, 0x90, 0x01, 0x2c}
	if _, err := conn.Write(ptrMsg); err != nil {
		t.Fatalf("write pointer event error: %v", err)
	}

	// Send release
	ptrMsg2 := []byte{5, 0, 0x01, 0x90, 0x01, 0x2c}
	if _, err := conn.Write(ptrMsg2); err != nil {
		t.Fatalf("write pointer release error: %v", err)
	}

	events := srv.GetPointerEvents()
	for i := 0; i < 50 && len(events) < 2; i++ {
		events = srv.GetPointerEvents()
		if len(events) < 2 {
			import_sleep(t)
		}
	}
	if len(events) < 2 {
		t.Fatalf("got %d pointer events, want 2", len(events))
	}
	if events[0].X != 400 || events[0].Y != 300 || events[0].ButtonMask != 1 {
		t.Errorf("event[0] = %+v, want {X:400, Y:300, ButtonMask:1}", events[0])
	}
}

// doHandshake performs the full RFB handshake and returns the connected conn.
func doHandshake(t *testing.T, addr string) net.Conn {
	t.Helper()
	conn, err := net.Dial("tcp", addr)
	if err != nil {
		t.Fatalf("dial error: %v", err)
	}

	// Version
	buf := make([]byte, 12)
	if _, err := conn.Read(buf); err != nil {
		t.Fatalf("read version error: %v", err)
	}
	if _, err := conn.Write([]byte("RFB 003.008\n")); err != nil {
		t.Fatalf("write version error: %v", err)
	}

	// Security
	secBuf := make([]byte, 2)
	if _, err := conn.Read(secBuf); err != nil {
		t.Fatalf("read security error: %v", err)
	}
	if _, err := conn.Write([]byte{1}); err != nil {
		t.Fatalf("write security error: %v", err)
	}

	// SecurityResult
	resultBuf := make([]byte, 4)
	if _, err := conn.Read(resultBuf); err != nil {
		t.Fatalf("read result error: %v", err)
	}

	// ClientInit
	if _, err := conn.Write([]byte{1}); err != nil {
		t.Fatalf("write client init error: %v", err)
	}

	// ServerInit - read and discard (width + height + pixel format + name)
	serverInitBuf := make([]byte, 24) // 2+2+16+4 = 24 min
	if _, err := conn.Read(serverInitBuf); err != nil {
		t.Fatalf("read server init error: %v", err)
	}
	// Read desktop name
	nameLen := binary.BigEndian.Uint32(serverInitBuf[20:24])
	if nameLen > 0 {
		nameBuf := make([]byte, nameLen)
		if _, err := conn.Read(nameBuf); err != nil {
			t.Fatalf("read desktop name error: %v", err)
		}
	}

	return conn
}

func import_sleep(t *testing.T) {
	t.Helper()
	// Use a channel-based sleep to avoid importing time in the test helpers
	ch := make(chan struct{})
	go func() {
		// ~10ms pause
		for i := 0; i < 1000000; i++ {
			_ = fmt.Sprintf("%d", i)
		}
		close(ch)
	}()
	<-ch
}
```

Actually, the test file above has issues with the sleep approach. Let me rewrite it properly:

Create `testutil/fakeserver_test.go`:
```go
package testutil

import (
	"encoding/binary"
	"image"
	"image/color"
	"net"
	"testing"
	"time"
)

func testImage() image.Image {
	img := image.NewRGBA(image.Rect(0, 0, 4, 4))
	for y := 0; y < 4; y++ {
		for x := 0; x < 4; x++ {
			img.Set(x, y, color.RGBA{R: uint8(x * 60), G: uint8(y * 60), B: 128, A: 255})
		}
	}
	return img
}

func TestFakeServerHandshake(t *testing.T) {
	srv := StartFakeVNCServer(t, testImage())

	conn, err := net.Dial("tcp", srv.Addr)
	if err != nil {
		t.Fatalf("dial error: %v", err)
	}
	defer conn.Close()

	// Read server protocol version
	buf := make([]byte, 12)
	if _, err := conn.Read(buf); err != nil {
		t.Fatalf("read version error: %v", err)
	}
	if string(buf) != "RFB 003.008\n" {
		t.Fatalf("version = %q, want %q", string(buf), "RFB 003.008\n")
	}

	// Send client protocol version
	if _, err := conn.Write([]byte("RFB 003.008\n")); err != nil {
		t.Fatalf("write version error: %v", err)
	}

	// Read security types (1 type: None=1)
	secBuf := make([]byte, 2)
	if _, err := conn.Read(secBuf); err != nil {
		t.Fatalf("read security types error: %v", err)
	}
	if secBuf[0] != 1 || secBuf[1] != 1 {
		t.Fatalf("security types = %v, want [1, 1]", secBuf)
	}

	// Send selected security type (None=1)
	if _, err := conn.Write([]byte{1}); err != nil {
		t.Fatalf("write security type error: %v", err)
	}

	// Read SecurityResult (0 = OK)
	var secResult uint32
	if err := binary.Read(conn, binary.BigEndian, &secResult); err != nil {
		t.Fatalf("read security result error: %v", err)
	}
	if secResult != 0 {
		t.Fatalf("security result = %d, want 0", secResult)
	}

	// Send ClientInit (shared=1)
	if _, err := conn.Write([]byte{1}); err != nil {
		t.Fatalf("write client init error: %v", err)
	}

	// Read ServerInit
	var width, height uint16
	if err := binary.Read(conn, binary.BigEndian, &width); err != nil {
		t.Fatalf("read width error: %v", err)
	}
	if err := binary.Read(conn, binary.BigEndian, &height); err != nil {
		t.Fatalf("read height error: %v", err)
	}
	if width != 4 || height != 4 {
		t.Fatalf("size = %dx%d, want 4x4", width, height)
	}
}

func TestFakeServerRecordsKeyEvent(t *testing.T) {
	srv := StartFakeVNCServer(t, testImage())
	conn := doHandshake(t, srv.Addr)
	defer conn.Close()

	// Send KeyEvent: msg-type=4, down-flag=1, padding=0,0, key=0xff0d
	keyMsg := []byte{4, 1, 0, 0, 0, 0, 0xff, 0x0d}
	if _, err := conn.Write(keyMsg); err != nil {
		t.Fatalf("write key event error: %v", err)
	}

	// Send key release
	keyMsg2 := []byte{4, 0, 0, 0, 0, 0, 0xff, 0x0d}
	if _, err := conn.Write(keyMsg2); err != nil {
		t.Fatalf("write key event 2 error: %v", err)
	}

	// Wait for server to process
	var events []KeyEvent
	for i := 0; i < 100; i++ {
		events = srv.GetKeyEvents()
		if len(events) >= 2 {
			break
		}
		time.Sleep(10 * time.Millisecond)
	}
	if len(events) < 2 {
		t.Fatalf("got %d key events, want >= 2", len(events))
	}
	if events[0].Key != 0xff0d || events[0].DownFlag != true {
		t.Errorf("event[0] = %+v, want {Key:0xff0d, DownFlag:true}", events[0])
	}
	if events[1].Key != 0xff0d || events[1].DownFlag != false {
		t.Errorf("event[1] = %+v, want {Key:0xff0d, DownFlag:false}", events[1])
	}
}

func TestFakeServerRecordsPointerEvent(t *testing.T) {
	srv := StartFakeVNCServer(t, testImage())
	conn := doHandshake(t, srv.Addr)
	defer conn.Close()

	// Send PointerEvent: msg-type=5, button-mask=1, x=400(0x0190), y=300(0x012c)
	ptrMsg := []byte{5, 1, 0x01, 0x90, 0x01, 0x2c}
	if _, err := conn.Write(ptrMsg); err != nil {
		t.Fatalf("write pointer event error: %v", err)
	}

	// Send release
	ptrMsg2 := []byte{5, 0, 0x01, 0x90, 0x01, 0x2c}
	if _, err := conn.Write(ptrMsg2); err != nil {
		t.Fatalf("write pointer release error: %v", err)
	}

	var events []PointerEvent
	for i := 0; i < 100; i++ {
		events = srv.GetPointerEvents()
		if len(events) >= 2 {
			break
		}
		time.Sleep(10 * time.Millisecond)
	}
	if len(events) < 2 {
		t.Fatalf("got %d pointer events, want >= 2", len(events))
	}
	if events[0].X != 400 || events[0].Y != 300 || events[0].ButtonMask != 1 {
		t.Errorf("event[0] = %+v, want {X:400, Y:300, ButtonMask:1}", events[0])
	}
	if events[1].ButtonMask != 0 {
		t.Errorf("event[1].ButtonMask = %d, want 0", events[1].ButtonMask)
	}
}

// doHandshake performs the full RFB 003.008 handshake with SecurityType None.
func doHandshake(t *testing.T, addr string) net.Conn {
	t.Helper()
	conn, err := net.Dial("tcp", addr)
	if err != nil {
		t.Fatalf("dial error: %v", err)
	}

	// Version exchange
	buf := make([]byte, 12)
	if _, err := conn.Read(buf); err != nil {
		t.Fatalf("read version error: %v", err)
	}
	if _, err := conn.Write([]byte("RFB 003.008\n")); err != nil {
		t.Fatalf("write version error: %v", err)
	}

	// Security types
	secBuf := make([]byte, 2)
	if _, err := conn.Read(secBuf); err != nil {
		t.Fatalf("read security error: %v", err)
	}
	if _, err := conn.Write([]byte{1}); err != nil {
		t.Fatalf("write security error: %v", err)
	}

	// SecurityResult
	resultBuf := make([]byte, 4)
	if _, err := conn.Read(resultBuf); err != nil {
		t.Fatalf("read result error: %v", err)
	}

	// ClientInit
	if _, err := conn.Write([]byte{1}); err != nil {
		t.Fatalf("write client init error: %v", err)
	}

	// ServerInit (2+2+16+4 = 24 bytes header + name)
	serverInitBuf := make([]byte, 24)
	if _, err := conn.Read(serverInitBuf); err != nil {
		t.Fatalf("read server init error: %v", err)
	}
	nameLen := binary.BigEndian.Uint32(serverInitBuf[20:24])
	if nameLen > 0 {
		nameBuf := make([]byte, nameLen)
		if _, err := conn.Read(nameBuf); err != nil {
			t.Fatalf("read desktop name error: %v", err)
		}
	}

	return conn
}
```

**Step 2: Run test to verify it fails**

Run:
```bash
go test ./testutil/ -v
```
Expected: FAIL — `StartFakeVNCServer` not defined.

**Step 3: Write fakeserver.go implementation**

Create `testutil/fakeserver.go`:
```go
package testutil

import (
	"encoding/binary"
	"image"
	"image/color"
	"io"
	"net"
	"sync"
	"testing"
)

// KeyEvent records a key event received by the fake server.
type KeyEvent struct {
	Key      uint32
	DownFlag bool
}

// PointerEvent records a pointer event received by the fake server.
type PointerEvent struct {
	X, Y       uint16
	ButtonMask uint8
}

// FakeVNCServer is a minimal RFB 003.008 server for testing.
type FakeVNCServer struct {
	Addr     string
	listener net.Listener
	img      image.Image

	mu        sync.Mutex
	keyEvents []KeyEvent
	ptrEvents []PointerEvent
}

// StartFakeVNCServer starts a fake VNC server on a random port.
// It is automatically stopped via t.Cleanup.
func StartFakeVNCServer(t *testing.T, framebufferImage image.Image) *FakeVNCServer {
	t.Helper()

	ln, err := net.Listen("tcp", "127.0.0.1:0")
	if err != nil {
		t.Fatalf("listen error: %v", err)
	}

	srv := &FakeVNCServer{
		Addr:     ln.Addr().String(),
		listener: ln,
		img:      framebufferImage,
	}

	t.Cleanup(func() {
		ln.Close()
	})

	go srv.acceptLoop()

	return srv
}

// GetKeyEvents returns a copy of all recorded key events.
func (s *FakeVNCServer) GetKeyEvents() []KeyEvent {
	s.mu.Lock()
	defer s.mu.Unlock()
	cp := make([]KeyEvent, len(s.keyEvents))
	copy(cp, s.keyEvents)
	return cp
}

// GetPointerEvents returns a copy of all recorded pointer events.
func (s *FakeVNCServer) GetPointerEvents() []PointerEvent {
	s.mu.Lock()
	defer s.mu.Unlock()
	cp := make([]PointerEvent, len(s.ptrEvents))
	copy(cp, s.ptrEvents)
	return cp
}

func (s *FakeVNCServer) acceptLoop() {
	for {
		conn, err := s.listener.Accept()
		if err != nil {
			return // listener closed
		}
		go s.handleConn(conn)
	}
}

func (s *FakeVNCServer) handleConn(conn net.Conn) {
	defer conn.Close()

	// --- Protocol Version ---
	if _, err := conn.Write([]byte("RFB 003.008\n")); err != nil {
		return
	}

	clientVersion := make([]byte, 12)
	if _, err := io.ReadFull(conn, clientVersion); err != nil {
		return
	}

	// --- Security ---
	// Send: 1 security type, type=None(1)
	if _, err := conn.Write([]byte{1, 1}); err != nil {
		return
	}

	// Read client's selected security type
	secType := make([]byte, 1)
	if _, err := io.ReadFull(conn, secType); err != nil {
		return
	}

	// Send SecurityResult (OK=0)
	if err := binary.Write(conn, binary.BigEndian, uint32(0)); err != nil {
		return
	}

	// --- ClientInit ---
	clientInit := make([]byte, 1)
	if _, err := io.ReadFull(conn, clientInit); err != nil {
		return
	}

	// --- ServerInit ---
	bounds := s.img.Bounds()
	width := uint16(bounds.Dx())
	height := uint16(bounds.Dy())

	// Width, Height
	binary.Write(conn, binary.BigEndian, width)
	binary.Write(conn, binary.BigEndian, height)

	// PixelFormat: 32-bit true color, RGBA
	pixelFormat := []byte{
		32,                // bits-per-pixel
		24,                // depth
		0,                 // big-endian-flag (little)
		1,                 // true-color-flag
		0, 255,            // red-max (255)
		0, 255,            // green-max (255)
		0, 255,            // blue-max (255)
		16,                // red-shift
		8,                 // green-shift
		0,                 // blue-shift
		0, 0, 0,           // padding
	}
	conn.Write(pixelFormat)

	// Desktop name
	name := []byte("fake")
	binary.Write(conn, binary.BigEndian, uint32(len(name)))
	conn.Write(name)

	// --- Main message loop ---
	for {
		msgType := make([]byte, 1)
		if _, err := io.ReadFull(conn, msgType); err != nil {
			return
		}

		switch msgType[0] {
		case 0: // SetPixelFormat
			buf := make([]byte, 19) // 3 padding + 16 pixel format
			if _, err := io.ReadFull(conn, buf); err != nil {
				return
			}

		case 2: // SetEncodings
			buf := make([]byte, 3) // 1 padding + 2 num-encodings
			if _, err := io.ReadFull(conn, buf); err != nil {
				return
			}
			numEncodings := binary.BigEndian.Uint16(buf[1:3])
			encBuf := make([]byte, 4*int(numEncodings))
			if _, err := io.ReadFull(conn, encBuf); err != nil {
				return
			}

		case 3: // FramebufferUpdateRequest
			buf := make([]byte, 9) // incremental(1) + x(2) + y(2) + w(2) + h(2)
			if _, err := io.ReadFull(conn, buf); err != nil {
				return
			}
			s.sendFramebufferUpdate(conn)

		case 4: // KeyEvent
			buf := make([]byte, 7) // down-flag(1) + padding(2) + key(4)
			if _, err := io.ReadFull(conn, buf); err != nil {
				return
			}
			down := buf[0] != 0
			key := binary.BigEndian.Uint32(buf[3:7])
			s.mu.Lock()
			s.keyEvents = append(s.keyEvents, KeyEvent{Key: key, DownFlag: down})
			s.mu.Unlock()

		case 5: // PointerEvent
			buf := make([]byte, 5) // button-mask(1) + x(2) + y(2)
			if _, err := io.ReadFull(conn, buf); err != nil {
				return
			}
			mask := buf[0]
			x := binary.BigEndian.Uint16(buf[1:3])
			y := binary.BigEndian.Uint16(buf[3:5])
			s.mu.Lock()
			s.ptrEvents = append(s.ptrEvents, PointerEvent{X: x, Y: y, ButtonMask: mask})
			s.mu.Unlock()

		case 6: // ClientCutText
			buf := make([]byte, 7) // padding(3) + length(4)
			if _, err := io.ReadFull(conn, buf); err != nil {
				return
			}
			textLen := binary.BigEndian.Uint32(buf[3:7])
			textBuf := make([]byte, textLen)
			if _, err := io.ReadFull(conn, textBuf); err != nil {
				return
			}

		default:
			return // unknown message
		}
	}
}

func (s *FakeVNCServer) sendFramebufferUpdate(conn net.Conn) {
	bounds := s.img.Bounds()
	width := uint16(bounds.Dx())
	height := uint16(bounds.Dy())

	// Message type (0) + padding (1) + number-of-rectangles (2)
	header := []byte{0, 0, 0, 1} // 1 rectangle
	conn.Write(header)

	// Rectangle header: x(2) + y(2) + width(2) + height(2) + encoding-type(4)
	binary.Write(conn, binary.BigEndian, uint16(0)) // x
	binary.Write(conn, binary.BigEndian, uint16(0)) // y
	binary.Write(conn, binary.BigEndian, width)
	binary.Write(conn, binary.BigEndian, height)
	binary.Write(conn, binary.BigEndian, int32(0)) // Raw encoding

	// Pixel data: 4 bytes per pixel (BGRA order for the pixel format we declared)
	for y := bounds.Min.Y; y < bounds.Max.Y; y++ {
		for x := bounds.Min.X; x < bounds.Max.X; x++ {
			r, g, b, _ := s.img.At(x, y).RGBA()
			// Pixel format: red-shift=16, green-shift=8, blue-shift=0, 32bpp little-endian
			// So pixel = (R << 16) | (G << 8) | B, sent as 4 bytes little-endian
			pixel := uint32(r>>8)<<16 | uint32(g>>8)<<8 | uint32(b>>8)
			binary.Write(conn, binary.BigEndian, pixel)
		}
	}
}
```

**Step 4: Run tests to verify they pass**

Run:
```bash
go test ./testutil/ -v
```
Expected: All fake server tests PASS.

**Step 5: Commit**

```bash
git add testutil/
git commit -m "feat: fake VNC server for testing (RFB 003.008 minimal impl)"
```

---

## Task 7: Real VNC Client Implementation

**Files:**
- Create: `vnc/realclient.go`
- Create: `vnc/realclient_test.go`

This implements the `VNCClient` interface using `github.com/kward/go-vnc`.

**Step 1: Add the dependency**

Run:
```bash
go get github.com/kward/go-vnc@latest
```

**Step 2: Write failing test using fake server**

Create `vnc/realclient_test.go`:
```go
package vnc

import (
	"image/color"
	"image"
	"testing"
	"time"

	"github.com/tjst-t/vncprobe/testutil"
)

func testImage() image.Image {
	img := image.NewRGBA(image.Rect(0, 0, 4, 4))
	for y := 0; y < 4; y++ {
		for x := 0; x < 4; x++ {
			img.Set(x, y, color.RGBA{R: uint8(x * 60), G: uint8(y * 60), B: 128, A: 255})
		}
	}
	return img
}

func TestRealClientConnectAndClose(t *testing.T) {
	img := testImage()
	srv := testutil.StartFakeVNCServer(t, img)

	client := NewRealClient()
	err := client.Connect(srv.Addr, "", 5*time.Second)
	if err != nil {
		t.Fatalf("Connect error: %v", err)
	}
	defer client.Close()
}

func TestRealClientSendKey(t *testing.T) {
	img := testImage()
	srv := testutil.StartFakeVNCServer(t, img)

	client := NewRealClient()
	if err := client.Connect(srv.Addr, "", 5*time.Second); err != nil {
		t.Fatalf("Connect error: %v", err)
	}
	defer client.Close()

	if err := client.SendKey(0xff0d, true); err != nil {
		t.Fatalf("SendKey error: %v", err)
	}
	if err := client.SendKey(0xff0d, false); err != nil {
		t.Fatalf("SendKey error: %v", err)
	}

	// Verify fake server received the events
	var events []testutil.KeyEvent
	for i := 0; i < 100; i++ {
		events = srv.GetKeyEvents()
		if len(events) >= 2 {
			break
		}
		time.Sleep(10 * time.Millisecond)
	}
	if len(events) < 2 {
		t.Fatalf("got %d key events, want >= 2", len(events))
	}
	if events[0].Key != 0xff0d || events[0].DownFlag != true {
		t.Errorf("event[0] = %+v", events[0])
	}
}

func TestRealClientSendPointer(t *testing.T) {
	img := testImage()
	srv := testutil.StartFakeVNCServer(t, img)

	client := NewRealClient()
	if err := client.Connect(srv.Addr, "", 5*time.Second); err != nil {
		t.Fatalf("Connect error: %v", err)
	}
	defer client.Close()

	if err := client.SendPointer(100, 200, 1); err != nil {
		t.Fatalf("SendPointer error: %v", err)
	}

	var events []testutil.PointerEvent
	for i := 0; i < 100; i++ {
		events = srv.GetPointerEvents()
		if len(events) >= 1 {
			break
		}
		time.Sleep(10 * time.Millisecond)
	}
	if len(events) < 1 {
		t.Fatalf("got %d pointer events, want >= 1", len(events))
	}
	if events[0].X != 100 || events[0].Y != 200 || events[0].ButtonMask != 1 {
		t.Errorf("event[0] = %+v", events[0])
	}
}

func TestRealClientCapture(t *testing.T) {
	img := testImage()
	srv := testutil.StartFakeVNCServer(t, img)

	client := NewRealClient()
	if err := client.Connect(srv.Addr, "", 5*time.Second); err != nil {
		t.Fatalf("Connect error: %v", err)
	}
	defer client.Close()

	captured, err := client.Capture()
	if err != nil {
		t.Fatalf("Capture error: %v", err)
	}

	bounds := captured.Bounds()
	if bounds.Dx() != 4 || bounds.Dy() != 4 {
		t.Fatalf("captured size = %dx%d, want 4x4", bounds.Dx(), bounds.Dy())
	}
}
```

**Step 3: Run test to verify it fails**

Run:
```bash
go test ./vnc/ -run "TestRealClient" -v
```
Expected: FAIL — `NewRealClient` not defined.

**Step 4: Write the real client implementation**

Create `vnc/realclient.go`:
```go
package vnc

import (
	"context"
	"fmt"
	"image"
	"image/color"
	"net"
	"time"

	govnc "github.com/kward/go-vnc"
	"github.com/kward/go-vnc/buttons"
	"github.com/kward/go-vnc/keys"
	"github.com/kward/go-vnc/messages"
	"github.com/kward/go-vnc/rfbflags"
)

// RealClient implements VNCClient using github.com/kward/go-vnc.
type RealClient struct {
	conn   *govnc.ClientConn
	nc     net.Conn
	config *govnc.ClientConfig
	msgCh  chan govnc.ServerMessage
}

// NewRealClient creates a new RealClient.
func NewRealClient() *RealClient {
	return &RealClient{}
}

func (c *RealClient) Connect(addr string, password string, timeout time.Duration) error {
	ctx, cancel := context.WithTimeout(context.Background(), timeout)
	defer cancel()

	dialer := net.Dialer{Timeout: timeout}
	nc, err := dialer.DialContext(ctx, "tcp", addr)
	if err != nil {
		return fmt.Errorf("connect to %s: %w", addr, err)
	}

	cfg := govnc.NewClientConfig(password)
	c.msgCh = make(chan govnc.ServerMessage, 100)
	cfg.ServerMessageCh = c.msgCh

	govnc.SetSettle(0) // disable UI settle delay for automation

	vc, err := govnc.Connect(ctx, nc, cfg)
	if err != nil {
		nc.Close()
		return fmt.Errorf("VNC handshake with %s: %w", addr, err)
	}

	c.conn = vc
	c.nc = nc
	c.config = cfg

	// Start listening for server messages in background
	go vc.ListenAndHandle()

	return nil
}

func (c *RealClient) Capture() (image.Image, error) {
	if c.conn == nil {
		return nil, fmt.Errorf("not connected")
	}

	w := c.conn.FramebufferWidth()
	h := c.conn.FramebufferHeight()

	// Request full framebuffer update
	if err := c.conn.FramebufferUpdateRequest(rfbflags.RFBFalse, 0, 0, w, h); err != nil {
		return nil, fmt.Errorf("framebuffer update request: %w", err)
	}

	// Wait for FramebufferUpdate response
	timeout := time.After(10 * time.Second)
	for {
		select {
		case msg := <-c.msgCh:
			if msg.Type() == messages.FramebufferUpdate {
				fbu, ok := msg.(*govnc.FramebufferUpdate)
				if !ok {
					return nil, fmt.Errorf("unexpected message type for FramebufferUpdate")
				}
				return framebufferToImage(w, h, fbu), nil
			}
			// Discard non-framebuffer messages
		case <-timeout:
			return nil, fmt.Errorf("timeout waiting for framebuffer update")
		}
	}
}

func (c *RealClient) SendKey(keycode uint32, down bool) error {
	if c.conn == nil {
		return fmt.Errorf("not connected")
	}
	return c.conn.KeyEvent(keys.Key(keycode), down)
}

func (c *RealClient) SendPointer(x, y uint16, buttonMask uint8) error {
	if c.conn == nil {
		return fmt.Errorf("not connected")
	}
	return c.conn.PointerEvent(buttons.Button(buttonMask), x, y)
}

func (c *RealClient) Close() error {
	if c.conn != nil {
		return c.conn.Close()
	}
	return nil
}

// framebufferToImage converts a FramebufferUpdate to an image.RGBA.
func framebufferToImage(width, height uint16, fbu *govnc.FramebufferUpdate) image.Image {
	img := image.NewRGBA(image.Rect(0, 0, int(width), int(height)))

	for _, rect := range fbu.Rects {
		raw, ok := rect.Enc.(*govnc.RawEncoding)
		if !ok {
			continue
		}
		i := 0
		for y := int(rect.Y); y < int(rect.Y+rect.Height); y++ {
			for x := int(rect.X); x < int(rect.X+rect.Width); x++ {
				if i < len(raw.Colors) {
					c := raw.Colors[i]
					img.Set(x, y, color.RGBA{
						R: uint8(c.R),
						G: uint8(c.G),
						B: uint8(c.B),
						A: 255,
					})
					i++
				}
			}
		}
	}

	return img
}
```

**Step 5: Run tests to verify they pass**

Run:
```bash
go test ./vnc/ -v -timeout 30s
```
Expected: All tests PASS (may need adjustment based on kward/go-vnc API compatibility with our fake server).

**Step 6: Commit**

```bash
git add vnc/realclient.go vnc/realclient_test.go go.mod go.sum
git commit -m "feat: real VNC client using kward/go-vnc"
```

---

## Task 8: CLI Commands — Tests First

**Files:**
- Create: `cmd/root.go`
- Create: `cmd/capture.go`
- Create: `cmd/key.go`
- Create: `cmd/typecmd.go`
- Create: `cmd/click.go`
- Create: `cmd/move.go`
- Modify: `main.go`
- Create: `cmd/cmd_test.go`

**Step 1: Write failing CLI tests**

Create `cmd/cmd_test.go`:
```go
package cmd

import (
	"testing"
)

func TestParseGlobalFlags(t *testing.T) {
	tests := []struct {
		name     string
		args     []string
		wantAddr string
		wantPass string
		wantTO   int
		wantErr  bool
	}{
		{
			name:     "short server flag",
			args:     []string{"-s", "10.0.0.1:5900"},
			wantAddr: "10.0.0.1:5900",
			wantTO:   10,
		},
		{
			name:     "long server flag",
			args:     []string{"--server", "10.0.0.1:5900"},
			wantAddr: "10.0.0.1:5900",
			wantTO:   10,
		},
		{
			name:     "with password and timeout",
			args:     []string{"-s", "10.0.0.1:5900", "-p", "secret", "--timeout", "30"},
			wantAddr: "10.0.0.1:5900",
			wantPass: "secret",
			wantTO:   30,
		},
		{
			name:    "missing server",
			args:    []string{},
			wantErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			opts, _, err := ParseGlobalFlags(tt.args)
			if tt.wantErr {
				if err == nil {
					t.Fatal("expected error, got nil")
				}
				return
			}
			if err != nil {
				t.Fatalf("unexpected error: %v", err)
			}
			if opts.Server != tt.wantAddr {
				t.Errorf("Server = %q, want %q", opts.Server, tt.wantAddr)
			}
			if opts.Password != tt.wantPass {
				t.Errorf("Password = %q, want %q", opts.Password, tt.wantPass)
			}
			if opts.Timeout != tt.wantTO {
				t.Errorf("Timeout = %d, want %d", opts.Timeout, tt.wantTO)
			}
		})
	}
}

func TestButtonFlag(t *testing.T) {
	tests := []struct {
		name    string
		button  int
		want    uint8
	}{
		{"left (default 1)", 1, 1},
		{"middle (2)", 2, 2},
		{"right (3)", 3, 4},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := ButtonNumberToMask(tt.button)
			if got != tt.want {
				t.Errorf("ButtonNumberToMask(%d) = %d, want %d", tt.button, got, tt.want)
			}
		})
	}
}
```

**Step 2: Run test to verify it fails**

Run:
```bash
go test ./cmd/ -v
```
Expected: FAIL — package doesn't exist.

**Step 3: Implement CLI root and commands**

Create `cmd/root.go`:
```go
package cmd

import (
	"flag"
	"fmt"
	"strings"
)

// GlobalOpts holds the global CLI options.
type GlobalOpts struct {
	Server   string
	Password string
	Timeout  int
}

// ParseGlobalFlags parses global flags from args and returns remaining args.
func ParseGlobalFlags(args []string) (*GlobalOpts, []string, error) {
	fs := flag.NewFlagSet("vncprobe", flag.ContinueOnError)
	opts := &GlobalOpts{}

	fs.StringVar(&opts.Server, "s", "", "VNC server address")
	fs.StringVar(&opts.Server, "server", "", "VNC server address")
	fs.StringVar(&opts.Password, "p", "", "VNC password")
	fs.StringVar(&opts.Password, "password", "", "VNC password")
	fs.IntVar(&opts.Timeout, "timeout", 10, "Connection timeout in seconds")

	if err := fs.Parse(args); err != nil {
		return nil, nil, err
	}

	if opts.Server == "" {
		return nil, nil, fmt.Errorf("server address is required (-s or --server)")
	}

	return opts, fs.Args(), nil
}

// ButtonNumberToMask converts a user-friendly button number (1=left, 2=middle, 3=right)
// to the RFB button bitmask.
func ButtonNumberToMask(button int) uint8 {
	switch button {
	case 1:
		return 1 // left
	case 2:
		return 2 // middle
	case 3:
		return 4 // right
	default:
		return 1 // default to left
	}
}

// Usage prints the usage message.
func Usage() string {
	var b strings.Builder
	b.WriteString("Usage: vncprobe <command> [options]\n\n")
	b.WriteString("Commands:\n")
	b.WriteString("  capture   Capture screen to PNG\n")
	b.WriteString("  key       Send key input\n")
	b.WriteString("  type      Type a string\n")
	b.WriteString("  click     Mouse click\n")
	b.WriteString("  move      Mouse move\n")
	b.WriteString("\nGlobal Options:\n")
	b.WriteString("  -s, --server    VNC server address (required)\n")
	b.WriteString("  -p, --password  VNC password\n")
	b.WriteString("  --timeout       Connection timeout in seconds (default: 10)\n")
	return b.String()
}
```

Create `cmd/capture.go`:
```go
package cmd

import (
	"flag"
	"fmt"

	"github.com/tjst-t/vncprobe/vnc"
)

// RunCapture executes the capture command.
func RunCapture(client vnc.VNCClient, args []string) error {
	fs := flag.NewFlagSet("capture", flag.ContinueOnError)
	output := fs.String("o", "screen.png", "Output PNG file path")

	if err := fs.Parse(args); err != nil {
		return err
	}

	return vnc.CaptureToFile(client, *output)
}

// CaptureUsage returns usage for the capture command.
func CaptureUsage() string {
	return fmt.Sprintf("Usage: vncprobe capture -s <server> [-o output.png]")
}
```

Create `cmd/key.go`:
```go
package cmd

import (
	"fmt"

	"github.com/tjst-t/vncprobe/vnc"
)

// RunKey executes the key command.
func RunKey(client vnc.VNCClient, args []string) error {
	if len(args) < 1 {
		return fmt.Errorf("key command requires a key name argument")
	}

	keyStr := args[0]
	actions, err := vnc.ParseKeySequence(keyStr)
	if err != nil {
		return fmt.Errorf("parse key %q: %w", keyStr, err)
	}

	return vnc.SendKeySequence(client, actions)
}
```

Create `cmd/typecmd.go`:
```go
package cmd

import (
	"fmt"
	"strings"

	"github.com/tjst-t/vncprobe/vnc"
)

// RunType executes the type command.
func RunType(client vnc.VNCClient, args []string) error {
	if len(args) < 1 {
		return fmt.Errorf("type command requires a text argument")
	}

	text := strings.Join(args, " ")
	return vnc.SendTypeString(client, text)
}
```

Create `cmd/click.go`:
```go
package cmd

import (
	"flag"
	"fmt"
	"strconv"

	"github.com/tjst-t/vncprobe/vnc"
)

// RunClick executes the click command.
func RunClick(client vnc.VNCClient, args []string) error {
	fs := flag.NewFlagSet("click", flag.ContinueOnError)
	button := fs.Int("button", 1, "Mouse button (1=left, 2=middle, 3=right)")

	if err := fs.Parse(args); err != nil {
		return err
	}

	remaining := fs.Args()
	if len(remaining) < 2 {
		return fmt.Errorf("click command requires x and y coordinates")
	}

	x, err := strconv.ParseUint(remaining[0], 10, 16)
	if err != nil {
		return fmt.Errorf("invalid x coordinate %q: %w", remaining[0], err)
	}
	y, err := strconv.ParseUint(remaining[1], 10, 16)
	if err != nil {
		return fmt.Errorf("invalid y coordinate %q: %w", remaining[1], err)
	}

	mask := ButtonNumberToMask(*button)
	return vnc.SendClick(client, uint16(x), uint16(y), mask)
}
```

Create `cmd/move.go`:
```go
package cmd

import (
	"fmt"
	"strconv"

	"github.com/tjst-t/vncprobe/vnc"
)

// RunMove executes the move command.
func RunMove(client vnc.VNCClient, args []string) error {
	if len(args) < 2 {
		return fmt.Errorf("move command requires x and y coordinates")
	}

	x, err := strconv.ParseUint(args[0], 10, 16)
	if err != nil {
		return fmt.Errorf("invalid x coordinate %q: %w", args[0], err)
	}
	y, err := strconv.ParseUint(args[1], 10, 16)
	if err != nil {
		return fmt.Errorf("invalid y coordinate %q: %w", args[1], err)
	}

	return vnc.SendMove(client, uint16(x), uint16(y))
}
```

**Step 4: Update main.go**

Replace `main.go`:
```go
package main

import (
	"fmt"
	"os"
	"time"

	"github.com/tjst-t/vncprobe/cmd"
	"github.com/tjst-t/vncprobe/vnc"
)

func main() {
	os.Exit(run(os.Args[1:]))
}

func run(args []string) int {
	if len(args) < 1 {
		fmt.Fprint(os.Stderr, cmd.Usage())
		return 1
	}

	command := args[0]
	remaining := args[1:]

	// Parse global flags from remaining args
	opts, cmdArgs, err := cmd.ParseGlobalFlags(remaining)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		return 1
	}

	// Connect to VNC server
	client := vnc.NewRealClient()
	if err := client.Connect(opts.Server, opts.Password, time.Duration(opts.Timeout)*time.Second); err != nil {
		fmt.Fprintf(os.Stderr, "Connection error: %v\n", err)
		return 2
	}
	defer client.Close()

	// Dispatch command
	switch command {
	case "capture":
		err = cmd.RunCapture(client, cmdArgs)
	case "key":
		err = cmd.RunKey(client, cmdArgs)
	case "type":
		err = cmd.RunType(client, cmdArgs)
	case "click":
		err = cmd.RunClick(client, cmdArgs)
	case "move":
		err = cmd.RunMove(client, cmdArgs)
	default:
		fmt.Fprintf(os.Stderr, "Unknown command: %s\n", command)
		fmt.Fprint(os.Stderr, cmd.Usage())
		return 1
	}

	if err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		return 3
	}
	return 0
}
```

**Step 5: Run tests**

Run:
```bash
go test ./cmd/ -v
go build -o vncprobe .
```
Expected: Tests PASS, binary builds.

**Step 6: Commit**

```bash
git add cmd/ main.go
git commit -m "feat: CLI commands (capture, key, type, click, move)"
```

---

## Task 9: E2E Tests

**Files:**
- Create: `e2e_test.go`

**Step 1: Write E2E tests**

Create `e2e_test.go`:
```go
package main

import (
	"image"
	"image/color"
	"image/png"
	"os"
	"path/filepath"
	"testing"
	"time"

	"github.com/tjst-t/vncprobe/testutil"
)

func loadTestImage(t *testing.T, path string) image.Image {
	t.Helper()
	f, err := os.Open(path)
	if err != nil {
		t.Fatalf("open %s: %v", path, err)
	}
	defer f.Close()
	img, err := png.Decode(f)
	if err != nil {
		t.Fatalf("decode %s: %v", path, err)
	}
	return img
}

func e2eImage() image.Image {
	img := image.NewRGBA(image.Rect(0, 0, 64, 64))
	for y := 0; y < 64; y++ {
		for x := 0; x < 64; x++ {
			img.Set(x, y, color.RGBA{R: uint8(x * 4), G: uint8(y * 4), B: 128, A: 255})
		}
	}
	return img
}

// runVncprobe calls the run() function directly (same process, no exec).
func runVncprobe(t *testing.T, args ...string) int {
	t.Helper()
	return run(args)
}

func TestE2ECapture(t *testing.T) {
	srv := testutil.StartFakeVNCServer(t, e2eImage())
	out := filepath.Join(t.TempDir(), "screen.png")

	code := runVncprobe(t, "capture", "-s", srv.Addr, "-o", out)
	if code != 0 {
		t.Fatalf("exit code = %d, want 0", code)
	}

	// Verify output file exists and is a valid PNG
	f, err := os.Open(out)
	if err != nil {
		t.Fatalf("open output: %v", err)
	}
	defer f.Close()
	decoded, err := png.Decode(f)
	if err != nil {
		t.Fatalf("decode output: %v", err)
	}
	bounds := decoded.Bounds()
	if bounds.Dx() != 64 || bounds.Dy() != 64 {
		t.Errorf("output size = %dx%d, want 64x64", bounds.Dx(), bounds.Dy())
	}
}

func TestE2EKey(t *testing.T) {
	srv := testutil.StartFakeVNCServer(t, e2eImage())

	code := runVncprobe(t, "key", "-s", srv.Addr, "enter")
	if code != 0 {
		t.Fatalf("exit code = %d, want 0", code)
	}

	// Wait for events
	var events []testutil.KeyEvent
	for i := 0; i < 100; i++ {
		events = srv.GetKeyEvents()
		if len(events) >= 2 {
			break
		}
		time.Sleep(10 * time.Millisecond)
	}
	if len(events) < 2 {
		t.Fatalf("got %d key events, want >= 2", len(events))
	}
	if events[0].Key != 0xff0d || events[0].DownFlag != true {
		t.Errorf("event[0] = %+v, want {Key:0xff0d, DownFlag:true}", events[0])
	}
	if events[1].Key != 0xff0d || events[1].DownFlag != false {
		t.Errorf("event[1] = %+v, want {Key:0xff0d, DownFlag:false}", events[1])
	}
}

func TestE2EKeyCombo(t *testing.T) {
	srv := testutil.StartFakeVNCServer(t, e2eImage())

	code := runVncprobe(t, "key", "-s", srv.Addr, "ctrl-c")
	if code != 0 {
		t.Fatalf("exit code = %d, want 0", code)
	}

	var events []testutil.KeyEvent
	for i := 0; i < 100; i++ {
		events = srv.GetKeyEvents()
		if len(events) >= 4 {
			break
		}
		time.Sleep(10 * time.Millisecond)
	}
	if len(events) < 4 {
		t.Fatalf("got %d key events, want >= 4 (ctrl down, c down, c up, ctrl up)", len(events))
	}
	// ctrl press
	if events[0].Key != 0xffe3 || events[0].DownFlag != true {
		t.Errorf("event[0] = %+v, want ctrl press", events[0])
	}
	// c press
	if events[1].Key != 0x0063 || events[1].DownFlag != true {
		t.Errorf("event[1] = %+v, want 'c' press", events[1])
	}
}

func TestE2EType(t *testing.T) {
	srv := testutil.StartFakeVNCServer(t, e2eImage())

	code := runVncprobe(t, "type", "-s", srv.Addr, "Hi")
	if code != 0 {
		t.Fatalf("exit code = %d, want 0", code)
	}

	var events []testutil.KeyEvent
	for i := 0; i < 100; i++ {
		events = srv.GetKeyEvents()
		if len(events) >= 4 {
			break
		}
		time.Sleep(10 * time.Millisecond)
	}
	if len(events) != 4 {
		t.Fatalf("got %d key events, want 4 (H press, H release, i press, i release)", len(events))
	}
	// 'H' = 0x0048
	if events[0].Key != 0x0048 || events[0].DownFlag != true {
		t.Errorf("event[0] = %+v, want H press", events[0])
	}
	if events[1].Key != 0x0048 || events[1].DownFlag != false {
		t.Errorf("event[1] = %+v, want H release", events[1])
	}
	// 'i' = 0x0069
	if events[2].Key != 0x0069 || events[2].DownFlag != true {
		t.Errorf("event[2] = %+v, want i press", events[2])
	}
	if events[3].Key != 0x0069 || events[3].DownFlag != false {
		t.Errorf("event[3] = %+v, want i release", events[3])
	}
}

func TestE2EClick(t *testing.T) {
	srv := testutil.StartFakeVNCServer(t, e2eImage())

	code := runVncprobe(t, "click", "-s", srv.Addr, "400", "300")
	if code != 0 {
		t.Fatalf("exit code = %d, want 0", code)
	}

	var events []testutil.PointerEvent
	for i := 0; i < 100; i++ {
		events = srv.GetPointerEvents()
		if len(events) >= 2 {
			break
		}
		time.Sleep(10 * time.Millisecond)
	}
	if len(events) < 2 {
		t.Fatalf("got %d pointer events, want >= 2", len(events))
	}
	if events[0].X != 400 || events[0].Y != 300 || events[0].ButtonMask != 1 {
		t.Errorf("press = %+v, want {X:400, Y:300, ButtonMask:1}", events[0])
	}
	if events[1].ButtonMask != 0 {
		t.Errorf("release ButtonMask = %d, want 0", events[1].ButtonMask)
	}
}

func TestE2EClickRightButton(t *testing.T) {
	srv := testutil.StartFakeVNCServer(t, e2eImage())

	code := runVncprobe(t, "click", "-s", srv.Addr, "--button", "3", "400", "300")
	if code != 0 {
		t.Fatalf("exit code = %d, want 0", code)
	}

	var events []testutil.PointerEvent
	for i := 0; i < 100; i++ {
		events = srv.GetPointerEvents()
		if len(events) >= 2 {
			break
		}
		time.Sleep(10 * time.Millisecond)
	}
	if len(events) < 2 {
		t.Fatalf("got %d pointer events, want >= 2", len(events))
	}
	if events[0].ButtonMask != 4 {
		t.Errorf("press ButtonMask = %d, want 4 (right)", events[0].ButtonMask)
	}
}

func TestE2EMove(t *testing.T) {
	srv := testutil.StartFakeVNCServer(t, e2eImage())

	code := runVncprobe(t, "move", "-s", srv.Addr, "500", "600")
	if code != 0 {
		t.Fatalf("exit code = %d, want 0", code)
	}

	var events []testutil.PointerEvent
	for i := 0; i < 100; i++ {
		events = srv.GetPointerEvents()
		if len(events) >= 1 {
			break
		}
		time.Sleep(10 * time.Millisecond)
	}
	if len(events) < 1 {
		t.Fatalf("got %d pointer events, want >= 1", len(events))
	}
	if events[0].X != 500 || events[0].Y != 600 || events[0].ButtonMask != 0 {
		t.Errorf("move = %+v, want {X:500, Y:600, ButtonMask:0}", events[0])
	}
}

func TestE2EMissingServer(t *testing.T) {
	code := runVncprobe(t, "capture")
	if code != 1 {
		t.Errorf("exit code = %d, want 1 (arg error)", code)
	}
}

func TestE2EUnknownCommand(t *testing.T) {
	code := runVncprobe(t, "foobar", "-s", "127.0.0.1:5900")
	if code != 1 {
		t.Errorf("exit code = %d, want 1", code)
	}
}

func TestE2ENoArgs(t *testing.T) {
	code := runVncprobe(t)
	if code != 1 {
		t.Errorf("exit code = %d, want 1", code)
	}
}
```

**Step 2: Run E2E tests**

Run:
```bash
go test -v -timeout 60s .
```
Expected: All E2E tests PASS.

**Step 3: Run all tests**

Run:
```bash
go test ./... -v -timeout 60s
```
Expected: All tests (unit + E2E) PASS.

**Step 4: Commit**

```bash
git add e2e_test.go
git commit -m "feat: E2E tests with fake VNC server"
```

---

## Task 10: Final Verification and Build

**Files:**
- No new files

**Step 1: Run all tests**

Run:
```bash
go test ./... -v -timeout 60s
```
Expected: All tests PASS.

**Step 2: Run vet**

Run:
```bash
go vet ./...
```
Expected: No issues.

**Step 3: Build the binary**

Run:
```bash
go build -o vncprobe .
```
Expected: Binary `vncprobe` created.

**Step 4: Verify binary runs**

Run:
```bash
./vncprobe
./vncprobe capture
./vncprobe key -s 127.0.0.1:1 enter 2>&1 || true
```
Expected: Usage message (exit 1), missing server error (exit 1), connection error (exit 2).

**Step 5: Final commit**

If any fixes were needed during verification, commit them.

---

## Notes for the Implementing Agent

### kward/go-vnc API Key Points

1. **Connection pattern**: `net.Dial` → `vnc.NewClientConfig(password)` → allocate `ServerMessageCh` → `vnc.Connect(ctx, conn, cfg)` → `go vc.ListenAndHandle()`

2. **ListenAndHandle calls defer Close()**: When it returns, the connection is closed. Don't call Close() again after ListenAndHandle returns.

3. **ServerMessageCh must be allocated**: `NewClientConfig` does NOT create the channel. You must do `cfg.ServerMessageCh = make(chan vnc.ServerMessage, 100)`.

4. **SetSettle(0)**: Disable the 25ms UI settle delay for automation speed.

5. **Only Raw encoding is implemented**: Our fake server only sends Raw, and the library only decodes Raw. This is fine for QEMU.

6. **Key constants**: Use `keys.Key(uint32)` to convert our keymap codes. The library's `keys` package has constants but we maintain our own mapping for CLI parsing.

7. **Button constants**: `buttons.Button(uint8)` — Left=1, Middle=2, Right=4, None=0.

8. **Pixel data**: `RawEncoding.Colors` contains `[]Color` with public `R, G, B uint16` fields. Shift right by 8 for uint8 values.

### Fake Server Protocol Details

The fake server implements RFB 003.008 with:
- Version: `RFB 003.008\n`
- Security: 1 type offered (None=1)
- SecurityResult: uint32(0) = OK
- ServerInit: width(u16) + height(u16) + PixelFormat(16 bytes) + nameLen(u32) + name
- PixelFormat: 32bpp, depth 24, little-endian, true-color, max 255 each, shifts 16/8/0
- FramebufferUpdate: Raw encoding, pixel data as 4 bytes per pixel matching the declared format
- Client messages: SetPixelFormat(0), SetEncodings(2), FBUpdateRequest(3), KeyEvent(4), PointerEvent(5), ClientCutText(6)

### Exit Codes

- 0: Success
- 1: Argument/usage error
- 2: Connection error
- 3: Operation error
